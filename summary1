gdb: outil de developpement logiciel.
gdb help and gdb help all permet de consulter la documentation (commandes pour faire tourner gdb suivant un gdb ./a.out). entree pour quitter gdb pour lancer le truc et tester ces derniers.
ctrl Z et pas ctrl C pour quitter l'interface de mise au point.
EXO_1:*****************************************
fichier gdb1.c.gz => decompresser avec gunzip. (on obtient le substitut : fichier gdb1.c;voilà)
Makefile + make + gdb ./$@ (premiere cible du Makefile)
Les symboles de debug sont bien trouves dans le binaire car avec gdb ./all on a avant (gdb) (console de commande d'interaction): Reading symbols from ./all qui permet de lire des choses specifiques faisant le lien entre le code source et les instructions binaires pour permettre de trouver des trucs dans le code source depuis l'execution partielle des instructions binaires.
list permet de lister le main + 5 lignes avant et 5 lignes apres ce dernier.
point d'arret:
=>break 6 puis run y permet de reprendre l'execution et de l'interrompre a la ligne 6 (entree du main).
Rq: le break 'line' permet de faire l'execution jusqu'a la ligne 'line' sans faire ce qui est demande dans la ligne 'line'.
=>arreter l'execution a l'entree de la ligne 'line' <=> contenu de 'line' pas interprete..
2ieme maniere d'y proceder: b main (break main) permet de s'arreter des le debut du main strictement.
br 'line' puis a une certaine etape ca m'affiche une boucle cela veut dire que l'entree a la boucle n'est pas encore faite.
Si on fait un break 'line' puis on fait un n un certain nombre de fois jusqu'a un appel de fonction comme sortie de "(gdb) n" et on fait un step on commande la prochaine instruction qui est l'execution de celle-ci par l'entree à la fonction ca affiche le prototype fonctionnel les adresses utiles puis on doit faire un n pour commencer a executer la 1ere fonctionnalite de la fonction *a=*a+1 par exemple pour test1.c (make all2 pour compilation) puis p *a affiche 1 car c'est juste un début d'execution puis un n va faire un return et c'est la que la derniere instruction a ete prise en compte ainsi un p *a affichera 2 puis n ligne par ligne fermera l'accolade pour marquer la fin de ce que fait step puis n va reafficher la source d'appel le main et la commande qui suit l'appel de fonction ici une boucle (test1.c) ; ainsi un p i de la meme maniere va afficher 0 mais un n va afficher la prochaien instruction add(&t[i],1) et donc i++ deja et donc p i => 1.
EXO_2:*********************************************
disp / p le premier permet d'afficher a chaque n et le deuxieme non a une etape fixee precise.
Remarque: un not run depuis le debut apres reading symbols from a.out ; un br 10 pour pouvoir le VOIR il FAUT TAPER r et non pas c(The programm is not being run);cela veut dire que le programme n'a pas tourné avant jusqu'a un breakpoint pour faire un n / c pour 'continuer'. 
Remarque2: make all28exec puis br 10 (test1.c) puis NON c mais R puis affichage mais pas execution de la ligne du breakpoint (ici la boucle for) puis :
a->c va continuer jusqu'a la fin ; c'est le terme.
b->n va executer l'affichage et afficher la ligne suivante (sans l'executer bien sur) ; c'est le principe de next.
Sur l'interface suivi de make all1_exec:
br 10 va afficher la commande de printf(..,..) puis un disp i et un disp t[i] va afficher respectivement (0,97 'a') puis on fait un n qui va executer la commande precedente qui concerne le printf qui affichera dans (gdb): 0 => a (on l'a passe un n affiche la sortie de al commande precedente ; deja detaille) et aussi la boucle (il faut une COMMANDE pour faire les liens) qui sera ici la boucle for avec i et t[i] (car on a fait un disp);ca serait bien evidemment 0,'a'((97)) puis si on fait un n , gdb va nous afficher la commande relative au breakpoint pour dire qu'il s'est arreter ici avec l'execution de la boucle donc i devient 2 (disp!!) et t[i] devient 98 'b'(code_ASCII) puis un n va executer la commande du breakpoint soit afficher: 1=>b et les valeurs de i,t[i] ainsi qu'une commande qui sera la boucle for comme precedemment;ainsi de suite.. Si il y a pas de breakpoint et pas de step prevue a l'avance, il execute normalement.(attention a cela!) Mais n permet de faire les trucs voire instructions si on veut etre clair pas a pas.
EXO_3:**************************
On peut suspendre l'execution suivant une condition qui verifie stoppe l'execution.
dans le fichier gdb1.c.gz apres un gunzip :: gdb1.c on fait un make all1_exec puis un br 10 puis info breakpoints pour tirer le numero du BREAK puis ON FAIT cond 1 (i==5) qui permet de parametrer le breakpoint et de l'appliquer si i vaut 5 et ca serait la ou l'execution d'un printf suivant un i qui vaut 5 ne s'appliquera pas ; ca parametre le breakpoint suivant id=1ICI , c'est ce qu'on appelle: arret conditionnel.
Si on applique ceci puis on fait r ca va afficher i=>t[i] pour tout i<5 la boucle qui va rendre i=5 puis entrer dans le printf avec cette valeur > tout cela va stopper l'affichage 
et afficher dans gdb la commande ou ona faitun break cad. 10 ou il y le printf bien evidemment pour marquer le break et avec l'affichage tout est clair. un p i affiche: $j(j nombre elements affiches avant)=5. Si on fait un next ca va afficher puis sortir dans gdb la boucle puis un n va faire sortir la commande printf et un p i va afficher la valeur incrementee dans l'avant sortie cad. la valeur $(j+2````)=6.
EXO_4:***************************************
Surveillance: la commande watch
si on fait :
make clean make all1_exec puis on definit un br a la ligne int i (8;//gdb1.c) puis un r ca va afficher une 'instruction(voir ce qui est avant)' pas d'affectation donc la suivante qui sera: la boucle for. Si on tape p i/ disp i ca va valoir la valeur sur la pile par defaut (via &i pages pile reservation des le debut adresse puis adressage par empilation) puis on tape watch i qui signifie que si on decide de continuer (C!!!!!) l'execution, une modification de i va suspendre l'execution, ici par exemple apres avoir tape watch i puis c ca va normalement afficher oldvalue newvalue + la commande qui a fait cela (apres celle du breakpoint bien naturellement###) , si on refait le meme processus avec un continue ca va reafficher la valeur de i (on a fait un disp voire 2 fois si le disp a ete fait 2 fois avant) et la commande de la boucle for ; on rappelle contrairement a ce qui precede qu'un p i affichera la nouvelle valeur par passage dans la boucle. Le next ne va pas faire le boulot grandiose de c pour s'adapter aux besoins logiciels de debug de la commande watch de gdb.
